import{c as dt,D as bt,G as gt,e as Tt,d as kt,L as wt,F as At,f as it,b as O,V as It,g as Pt,h as Mt,i as St,j as lt,k as Nt,l as ft,m as rt}from"./three.module.165a5894.js";import{d as Et,i as Ct,w as jt}from"./index.f42c671b.js";class at extends wt{constructor(C){super(C),this.defaultDPI=90,this.defaultUnit="px"}load(C,q,j,M){const w=this,F=new At(w.manager);F.setPath(w.path),F.setRequestHeader(w.requestHeader),F.setWithCredentials(w.withCredentials),F.load(C,function(_){try{q(w.parse(_))}catch(Z){M?M(Z):console.error(Z),w.manager.itemError(C)}},j,M)}parse(C){const q=this;function j(i,r){if(i.nodeType!==1)return;const t=h(i);let o=!0,c=null;switch(i.nodeName){case"svg":break;case"style":w(i);break;case"g":r=R(i,r);break;case"path":r=R(i,r),i.hasAttribute("d")&&(c=M(i));break;case"rect":r=R(i,r),c=Z(i);break;case"polygon":r=R(i,r),c=Y(i);break;case"polyline":r=R(i,r),c=K(i);break;case"circle":r=R(i,r),c=B(i);break;case"ellipse":r=R(i,r),c=v(i);break;case"line":r=R(i,r),c=tt(i);break;case"defs":o=!1;break;case"use":r=R(i,r);const s=i.href.baseVal.substring(1),a=i.viewportElement.getElementById(s);a?j(a,r):console.warn("SVGLoader: 'use node' references non-existent node id: "+s);break}if(c&&(r.fill!==void 0&&r.fill!=="none"&&c.color.setStyle(r.fill),S(c,Q),z.push(c),c.userData={node:i,style:r}),o){const s=i.childNodes;for(let a=0;a<s.length;a++)j(s[a],r)}t&&(d.pop(),d.length>0?Q.copy(d[d.length-1]):Q.identity())}function M(i){const r=new rt,t=new O,o=new O,c=new O;let s=!0,a=!1;const b=i.getAttribute("d").match(/[a-df-z][^a-df-z]*/ig);for(let T=0,y=b.length;T<y;T++){const V=b[T],u=V.charAt(0),p=V.substr(1).trim();s===!0&&(a=!0,s=!1);let n;switch(u){case"M":n=f(p);for(let e=0,x=n.length;e<x;e+=2)t.x=n[e+0],t.y=n[e+1],o.x=t.x,o.y=t.y,e===0?r.moveTo(t.x,t.y):r.lineTo(t.x,t.y),e===0&&c.copy(t);break;case"H":n=f(p);for(let e=0,x=n.length;e<x;e++)t.x=n[e],o.x=t.x,o.y=t.y,r.lineTo(t.x,t.y),e===0&&a===!0&&c.copy(t);break;case"V":n=f(p);for(let e=0,x=n.length;e<x;e++)t.y=n[e],o.x=t.x,o.y=t.y,r.lineTo(t.x,t.y),e===0&&a===!0&&c.copy(t);break;case"L":n=f(p);for(let e=0,x=n.length;e<x;e+=2)t.x=n[e+0],t.y=n[e+1],o.x=t.x,o.y=t.y,r.lineTo(t.x,t.y),e===0&&a===!0&&c.copy(t);break;case"C":n=f(p);for(let e=0,x=n.length;e<x;e+=6)r.bezierCurveTo(n[e+0],n[e+1],n[e+2],n[e+3],n[e+4],n[e+5]),o.x=n[e+2],o.y=n[e+3],t.x=n[e+4],t.y=n[e+5],e===0&&a===!0&&c.copy(t);break;case"S":n=f(p);for(let e=0,x=n.length;e<x;e+=4)r.bezierCurveTo(D(t.x,o.x),D(t.y,o.y),n[e+0],n[e+1],n[e+2],n[e+3]),o.x=n[e+0],o.y=n[e+1],t.x=n[e+2],t.y=n[e+3],e===0&&a===!0&&c.copy(t);break;case"Q":n=f(p);for(let e=0,x=n.length;e<x;e+=4)r.quadraticCurveTo(n[e+0],n[e+1],n[e+2],n[e+3]),o.x=n[e+0],o.y=n[e+1],t.x=n[e+2],t.y=n[e+3],e===0&&a===!0&&c.copy(t);break;case"T":n=f(p);for(let e=0,x=n.length;e<x;e+=2){const L=D(t.x,o.x),X=D(t.y,o.y);r.quadraticCurveTo(L,X,n[e+0],n[e+1]),o.x=L,o.y=X,t.x=n[e+0],t.y=n[e+1],e===0&&a===!0&&c.copy(t)}break;case"A":n=f(p,[3,4],7);for(let e=0,x=n.length;e<x;e+=7){if(n[e+5]==t.x&&n[e+6]==t.y)continue;const L=t.clone();t.x=n[e+5],t.y=n[e+6],o.x=t.x,o.y=t.y,F(r,n[e],n[e+1],n[e+2],n[e+3],n[e+4],L,t),e===0&&a===!0&&c.copy(t)}break;case"m":n=f(p);for(let e=0,x=n.length;e<x;e+=2)t.x+=n[e+0],t.y+=n[e+1],o.x=t.x,o.y=t.y,e===0?r.moveTo(t.x,t.y):r.lineTo(t.x,t.y),e===0&&c.copy(t);break;case"h":n=f(p);for(let e=0,x=n.length;e<x;e++)t.x+=n[e],o.x=t.x,o.y=t.y,r.lineTo(t.x,t.y),e===0&&a===!0&&c.copy(t);break;case"v":n=f(p);for(let e=0,x=n.length;e<x;e++)t.y+=n[e],o.x=t.x,o.y=t.y,r.lineTo(t.x,t.y),e===0&&a===!0&&c.copy(t);break;case"l":n=f(p);for(let e=0,x=n.length;e<x;e+=2)t.x+=n[e+0],t.y+=n[e+1],o.x=t.x,o.y=t.y,r.lineTo(t.x,t.y),e===0&&a===!0&&c.copy(t);break;case"c":n=f(p);for(let e=0,x=n.length;e<x;e+=6)r.bezierCurveTo(t.x+n[e+0],t.y+n[e+1],t.x+n[e+2],t.y+n[e+3],t.x+n[e+4],t.y+n[e+5]),o.x=t.x+n[e+2],o.y=t.y+n[e+3],t.x+=n[e+4],t.y+=n[e+5],e===0&&a===!0&&c.copy(t);break;case"s":n=f(p);for(let e=0,x=n.length;e<x;e+=4)r.bezierCurveTo(D(t.x,o.x),D(t.y,o.y),t.x+n[e+0],t.y+n[e+1],t.x+n[e+2],t.y+n[e+3]),o.x=t.x+n[e+0],o.y=t.y+n[e+1],t.x+=n[e+2],t.y+=n[e+3],e===0&&a===!0&&c.copy(t);break;case"q":n=f(p);for(let e=0,x=n.length;e<x;e+=4)r.quadraticCurveTo(t.x+n[e+0],t.y+n[e+1],t.x+n[e+2],t.y+n[e+3]),o.x=t.x+n[e+0],o.y=t.y+n[e+1],t.x+=n[e+2],t.y+=n[e+3],e===0&&a===!0&&c.copy(t);break;case"t":n=f(p);for(let e=0,x=n.length;e<x;e+=2){const L=D(t.x,o.x),X=D(t.y,o.y);r.quadraticCurveTo(L,X,t.x+n[e+0],t.y+n[e+1]),o.x=L,o.y=X,t.x=t.x+n[e+0],t.y=t.y+n[e+1],e===0&&a===!0&&c.copy(t)}break;case"a":n=f(p,[3,4],7);for(let e=0,x=n.length;e<x;e+=7){if(n[e+5]==0&&n[e+6]==0)continue;const L=t.clone();t.x+=n[e+5],t.y+=n[e+6],o.x=t.x,o.y=t.y,F(r,n[e],n[e+1],n[e+2],n[e+3],n[e+4],L,t),e===0&&a===!0&&c.copy(t)}break;case"Z":case"z":r.currentPath.autoClose=!0,r.currentPath.curves.length>0&&(t.copy(c),r.currentPath.currentPoint.copy(t),s=!0);break;default:console.warn(V)}a=!1}return r}function w(i){if(!(!i.sheet||!i.sheet.cssRules||!i.sheet.cssRules.length))for(let r=0;r<i.sheet.cssRules.length;r++){const t=i.sheet.cssRules[r];if(t.type!==1)continue;const o=t.selectorText.split(/,/gm).filter(Boolean).map(c=>c.trim());for(let c=0;c<o.length;c++)W[o[c]]=Object.assign(W[o[c]]||{},t.style)}}function F(i,r,t,o,c,s,a,P){if(r==0||t==0){i.lineTo(P.x,P.y);return}o=o*Math.PI/180,r=Math.abs(r),t=Math.abs(t);const b=(a.x-P.x)/2,T=(a.y-P.y)/2,y=Math.cos(o)*b+Math.sin(o)*T,V=-Math.sin(o)*b+Math.cos(o)*T;let u=r*r,p=t*t;const n=y*y,e=V*V,x=n/u+e/p;if(x>1){const yt=Math.sqrt(x);r=yt*r,t=yt*t,u=r*r,p=t*t}const L=u*e+p*n,X=(u*p-L)/L;let et=Math.sqrt(Math.max(0,X));c===s&&(et=-et);const st=et*r*V/t,ct=-et*t*y/r,pt=Math.cos(o)*st-Math.sin(o)*ct+(a.x+P.x)/2,mt=Math.sin(o)*st+Math.cos(o)*ct+(a.y+P.y)/2,ht=_(1,0,(y-st)/r,(V-ct)/t),xt=_((y-st)/r,(V-ct)/t,(-y-st)/r,(-V-ct)/t)%(Math.PI*2);i.currentPath.absellipse(pt,mt,r,t,ht,ht+xt,s===0,o)}function _(i,r,t,o){const c=i*t+r*o,s=Math.sqrt(i*i+r*r)*Math.sqrt(t*t+o*o);let a=Math.acos(Math.max(-1,Math.min(1,c/s)));return i*o-r*t<0&&(a=-a),a}function Z(i){const r=m(i.getAttribute("x")||0),t=m(i.getAttribute("y")||0),o=m(i.getAttribute("rx")||i.getAttribute("ry")||0),c=m(i.getAttribute("ry")||i.getAttribute("rx")||0),s=m(i.getAttribute("width")),a=m(i.getAttribute("height")),P=1-.551915024494,b=new rt;return b.moveTo(r+o,t),b.lineTo(r+s-o,t),(o!==0||c!==0)&&b.bezierCurveTo(r+s-o*P,t,r+s,t+c*P,r+s,t+c),b.lineTo(r+s,t+a-c),(o!==0||c!==0)&&b.bezierCurveTo(r+s,t+a-c*P,r+s-o*P,t+a,r+s-o,t+a),b.lineTo(r+o,t+a),(o!==0||c!==0)&&b.bezierCurveTo(r+o*P,t+a,r,t+a-c*P,r,t+a-c),b.lineTo(r,t+c),(o!==0||c!==0)&&b.bezierCurveTo(r,t+c*P,r+o*P,t,r+o,t),b}function Y(i){function r(s,a,P){const b=m(a),T=m(P);c===0?o.moveTo(b,T):o.lineTo(b,T),c++}const t=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,o=new rt;let c=0;return i.getAttribute("points").replace(t,r),o.currentPath.autoClose=!0,o}function K(i){function r(s,a,P){const b=m(a),T=m(P);c===0?o.moveTo(b,T):o.lineTo(b,T),c++}const t=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,o=new rt;let c=0;return i.getAttribute("points").replace(t,r),o.currentPath.autoClose=!1,o}function B(i){const r=m(i.getAttribute("cx")||0),t=m(i.getAttribute("cy")||0),o=m(i.getAttribute("r")||0),c=new lt;c.absarc(r,t,o,0,Math.PI*2);const s=new rt;return s.subPaths.push(c),s}function v(i){const r=m(i.getAttribute("cx")||0),t=m(i.getAttribute("cy")||0),o=m(i.getAttribute("rx")||0),c=m(i.getAttribute("ry")||0),s=new lt;s.absellipse(r,t,o,c,0,Math.PI*2);const a=new rt;return a.subPaths.push(s),a}function tt(i){const r=m(i.getAttribute("x1")||0),t=m(i.getAttribute("y1")||0),o=m(i.getAttribute("x2")||0),c=m(i.getAttribute("y2")||0),s=new rt;return s.moveTo(r,t),s.lineTo(o,c),s.currentPath.autoClose=!1,s}function R(i,r){r=Object.assign({},r);let t={};if(i.hasAttribute("class")){const a=i.getAttribute("class").split(/\s/).filter(Boolean).map(P=>P.trim());for(let P=0;P<a.length;P++)t=Object.assign(t,W["."+a[P]])}i.hasAttribute("id")&&(t=Object.assign(t,W["#"+i.getAttribute("id")]));function o(a,P,b){b===void 0&&(b=function(y){return y.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),y}),i.hasAttribute(a)&&(r[P]=b(i.getAttribute(a))),t[a]&&(r[P]=b(t[a])),i.style&&i.style[a]!==""&&(r[P]=b(i.style[a]))}function c(a){return Math.max(0,Math.min(1,m(a)))}function s(a){return Math.max(0,m(a))}return o("fill","fill"),o("fill-opacity","fillOpacity",c),o("fill-rule","fillRule"),o("opacity","opacity",c),o("stroke","stroke"),o("stroke-opacity","strokeOpacity",c),o("stroke-width","strokeWidth",s),o("stroke-linejoin","strokeLineJoin"),o("stroke-linecap","strokeLineCap"),o("stroke-miterlimit","strokeMiterLimit",s),o("visibility","visibility"),r}function D(i,r){return i-(r-i)}function f(i,r,t){if(typeof i!="string")throw new TypeError("Invalid input: "+typeof i);const o={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},c=0,s=1,a=2,P=3;let b=c,T=!0,y="",V="";const u=[];function p(L,X,et){const st=new SyntaxError('Unexpected character "'+L+'" at index '+X+".");throw st.partial=et,st}function n(){y!==""&&(V===""?u.push(Number(y)):u.push(Number(y)*Math.pow(10,Number(V)))),y="",V=""}let e;const x=i.length;for(let L=0;L<x;L++){if(e=i[L],Array.isArray(r)&&r.includes(u.length%t)&&o.FLAGS.test(e)){b=s,y=e,n();continue}if(b===c){if(o.WHITESPACE.test(e))continue;if(o.DIGIT.test(e)||o.SIGN.test(e)){b=s,y=e;continue}if(o.POINT.test(e)){b=a,y=e;continue}o.COMMA.test(e)&&(T&&p(e,L,u),T=!0)}if(b===s){if(o.DIGIT.test(e)){y+=e;continue}if(o.POINT.test(e)){y+=e,b=a;continue}if(o.EXP.test(e)){b=P;continue}o.SIGN.test(e)&&y.length===1&&o.SIGN.test(y[0])&&p(e,L,u)}if(b===a){if(o.DIGIT.test(e)){y+=e;continue}if(o.EXP.test(e)){b=P;continue}o.POINT.test(e)&&y[y.length-1]==="."&&p(e,L,u)}if(b===P){if(o.DIGIT.test(e)){V+=e;continue}if(o.SIGN.test(e)){if(V===""){V+=e;continue}V.length===1&&o.SIGN.test(V)&&p(e,L,u)}}o.WHITESPACE.test(e)?(n(),b=c,T=!1):o.COMMA.test(e)?(n(),b=c,T=!0):o.SIGN.test(e)?(n(),b=s,y=e):o.POINT.test(e)?(n(),b=a,y=e):p(e,L,u)}return n(),u}const k=["mm","cm","in","pt","pc","px"],E={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:72/6,pc:1,px:-1},px:{px:1}};function m(i){let r="px";if(typeof i=="string"||i instanceof String)for(let o=0,c=k.length;o<c;o++){const s=k[o];if(i.endsWith(s)){r=s,i=i.substring(0,i.length-s.length);break}}let t;return r==="px"&&q.defaultUnit!=="px"?t=E.in[q.defaultUnit]/q.defaultDPI:(t=E[r][q.defaultUnit],t<0&&(t=E[r].in*q.defaultDPI)),t*parseFloat(i)}function h(i){if(!(i.hasAttribute("transform")||i.nodeName==="use"&&(i.hasAttribute("x")||i.hasAttribute("y"))))return null;const r=g(i);return d.length>0&&r.premultiply(d[d.length-1]),Q.copy(r),d.push(r),r}function g(i){const r=new it,t=J;if(i.nodeName==="use"&&(i.hasAttribute("x")||i.hasAttribute("y"))){const o=m(i.getAttribute("x")),c=m(i.getAttribute("y"));r.translate(o,c)}if(i.hasAttribute("transform")){const o=i.getAttribute("transform").split(")");for(let c=o.length-1;c>=0;c--){const s=o[c].trim();if(s==="")continue;const a=s.indexOf("("),P=s.length;if(a>0&&a<P){const b=s.substr(0,a),T=f(s.substr(a+1,P-a-1));switch(t.identity(),b){case"translate":if(T.length>=1){const y=T[0];let V=y;T.length>=2&&(V=T[1]),t.translate(y,V)}break;case"rotate":if(T.length>=1){let y=0,V=0,u=0;y=-T[0]*Math.PI/180,T.length>=3&&(V=T[1],u=T[2]),H.identity().translate(-V,-u),$.identity().rotate(y),nt.multiplyMatrices($,H),H.identity().translate(V,u),t.multiplyMatrices(H,nt)}break;case"scale":if(T.length>=1){const y=T[0];let V=y;T.length>=2&&(V=T[1]),t.scale(y,V)}break;case"skewX":T.length===1&&t.set(1,Math.tan(T[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":T.length===1&&t.set(1,0,0,Math.tan(T[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":T.length===6&&t.set(T[0],T[2],T[4],T[1],T[3],T[5],0,0,1);break}}r.premultiply(t)}}return r}function S(i,r){function t(s){l.set(s.x,s.y,1).applyMatrix3(r),s.set(l.x,l.y)}const o=N(r),c=i.subPaths;for(let s=0,a=c.length;s<a;s++){const b=c[s].curves;for(let T=0;T<b.length;T++){const y=b[T];y.isLineCurve?(t(y.v1),t(y.v2)):y.isCubicBezierCurve?(t(y.v0),t(y.v1),t(y.v2),t(y.v3)):y.isQuadraticBezierCurve?(t(y.v0),t(y.v1),t(y.v2)):y.isEllipseCurve&&(o&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),A.set(y.aX,y.aY),t(A),y.aX=A.x,y.aY=A.y,y.xRadius*=I(r),y.yRadius*=G(r))}}}function N(i){return i.elements[1]!==0||i.elements[3]!==0}function I(i){const r=i.elements;return Math.sqrt(r[0]*r[0]+r[1]*r[1])}function G(i){const r=i.elements;return Math.sqrt(r[3]*r[3]+r[4]*r[4])}const z=[],W={},d=[],J=new it,H=new it,$=new it,nt=new it,A=new O,l=new It,Q=new it,U=new DOMParser().parseFromString(C,"image/svg+xml");return j(U.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:z,xml:U.documentElement}}static createShapes(C){const j={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},M={loc:j.ORIGIN,t:0};function w(f,k,E,m){const h=f.x,g=k.x,S=E.x,N=m.x,I=f.y,G=k.y,z=E.y,W=m.y,d=(N-S)*(I-z)-(W-z)*(h-S),J=(g-h)*(I-z)-(G-I)*(h-S),H=(W-z)*(g-h)-(N-S)*(G-I),$=d/H,nt=J/H;if(H===0&&d!==0||$<=0||$>=1||nt<0||nt>1)return null;if(d===0&&H===0){for(let A=0;A<2;A++)if(F(A===0?E:m,f,k),M.loc==j.ORIGIN){const l=A===0?E:m;return{x:l.x,y:l.y,t:M.t}}else if(M.loc==j.BETWEEN){const l=+(h+M.t*(g-h)).toPrecision(10),Q=+(I+M.t*(G-I)).toPrecision(10);return{x:l,y:Q,t:M.t}}return null}else{for(let Q=0;Q<2;Q++)if(F(Q===0?E:m,f,k),M.loc==j.ORIGIN){const U=Q===0?E:m;return{x:U.x,y:U.y,t:M.t}}const A=+(h+$*(g-h)).toPrecision(10),l=+(I+$*(G-I)).toPrecision(10);return{x:A,y:l,t:$}}}function F(f,k,E){const m=E.x-k.x,h=E.y-k.y,g=f.x-k.x,S=f.y-k.y,N=m*S-g*h;if(f.x===k.x&&f.y===k.y){M.loc=j.ORIGIN,M.t=0;return}if(f.x===E.x&&f.y===E.y){M.loc=j.DESTINATION,M.t=1;return}if(N<-Number.EPSILON){M.loc=j.LEFT;return}if(N>Number.EPSILON){M.loc=j.RIGHT;return}if(m*g<0||h*S<0){M.loc=j.BEHIND;return}if(Math.sqrt(m*m+h*h)<Math.sqrt(g*g+S*S)){M.loc=j.BEYOND;return}let I;m!==0?I=g/m:I=S/h,M.loc=j.BETWEEN,M.t=I}function _(f,k){const E=[],m=[];for(let h=1;h<f.length;h++){const g=f[h-1],S=f[h];for(let N=1;N<k.length;N++){const I=k[N-1],G=k[N],z=w(g,S,I,G);z!==null&&E.find(W=>W.t<=z.t+Number.EPSILON&&W.t>=z.t-Number.EPSILON)===void 0&&(E.push(z),m.push(new O(z.x,z.y)))}}return m}function Z(f,k,E){const m=new O;k.getCenter(m);const h=[];return E.forEach(g=>{g.boundingBox.containsPoint(m)&&_(f,g.points).forEach(N=>{h.push({identifier:g.identifier,isCW:g.isCW,point:N})})}),h.sort((g,S)=>g.point.x-S.point.x),h}function Y(f,k,E,m,h){(h==null||h==="")&&(h="nonzero");const g=new O;f.boundingBox.getCenter(g);const S=[new O(E,g.y),new O(m,g.y)],N=Z(S,f.boundingBox,k);N.sort((J,H)=>J.point.x-H.point.x);const I=[],G=[];N.forEach(J=>{J.identifier===f.identifier?I.push(J):G.push(J)});const z=I[0].point.x,W=[];let d=0;for(;d<G.length&&G[d].point.x<z;)W.length>0&&W[W.length-1]===G[d].identifier?W.pop():W.push(G[d].identifier),d++;if(W.push(f.identifier),h==="evenodd"){const J=W.length%2===0,H=W[W.length-2];return{identifier:f.identifier,isHole:J,for:H}}else if(h==="nonzero"){let J=!0,H=null,$=null;for(let nt=0;nt<W.length;nt++){const A=W[nt];J?($=k[A].isCW,J=!1,H=A):$!==k[A].isCW&&($=k[A].isCW,J=!0)}return{identifier:f.identifier,isHole:J,for:H}}else console.warn('fill-rule: "'+h+'" is currently not implemented.')}let K=0,B=999999999,v=-999999999,tt=C.subPaths.map(f=>{const k=f.getPoints();let E=-999999999,m=999999999,h=-999999999,g=999999999;for(let S=0;S<k.length;S++){const N=k[S];N.y>E&&(E=N.y),N.y<m&&(m=N.y),N.x>h&&(h=N.x),N.x<g&&(g=N.x)}return v<=h&&(v=h+1),B>=g&&(B=g-1),{curves:f.curves,points:k,isCW:Pt.isClockWise(k),identifier:K++,boundingBox:new Mt(new O(g,m),new O(h,E))}});tt=tt.filter(f=>f.points.length>1);const R=tt.map(f=>Y(f,tt,B,v,C.userData.style.fillRule)),D=[];return tt.forEach(f=>{if(!R[f.identifier].isHole){const E=new St;E.curves=f.curves,R.filter(h=>h.isHole&&h.for===f.identifier).forEach(h=>{const g=tt[h.identifier],S=new lt;S.curves=g.curves,E.holes.push(S)}),D.push(E)}}),D}static getStrokeStyle(C,q,j,M,w){return C=C!==void 0?C:1,q=q!==void 0?q:"#000",j=j!==void 0?j:"miter",M=M!==void 0?M:"butt",w=w!==void 0?w:4,{strokeColor:q,strokeWidth:C,strokeLineJoin:j,strokeLineCap:M,strokeMiterLimit:w}}static pointsToStroke(C,q,j,M){const w=[],F=[],_=[];if(at.pointsToStrokeWithBuffers(C,q,j,M,w,F,_)===0)return null;const Z=new Nt;return Z.setAttribute("position",new ft(w,3)),Z.setAttribute("normal",new ft(F,3)),Z.setAttribute("uv",new ft(_,2)),Z}static pointsToStrokeWithBuffers(C,q,j,M,w,F,_,Z){const Y=new O,K=new O,B=new O,v=new O,tt=new O,R=new O,D=new O,f=new O,k=new O,E=new O,m=new O,h=new O,g=new O,S=new O,N=new O,I=new O,G=new O;j=j!==void 0?j:12,M=M!==void 0?M:.001,Z=Z!==void 0?Z:0,C=V(C);const z=C.length;if(z<2)return 0;const W=C[0].equals(C[z-1]);let d,J=C[0],H;const $=q.strokeWidth/2,nt=1/(z-1);let A=0,l,Q,U,ot,i=!1,r=0,t=Z*3,o=Z*2;c(C[0],C[1],Y).multiplyScalar($),f.copy(C[0]).sub(Y),k.copy(C[0]).add(Y),E.copy(f),m.copy(k);for(let u=1;u<z;u++){d=C[u],u===z-1?W?H=C[1]:H=void 0:H=C[u+1];const p=Y;if(c(J,d,p),B.copy(p).multiplyScalar($),h.copy(d).sub(B),g.copy(d).add(B),l=A+nt,Q=!1,H!==void 0){c(d,H,K),B.copy(K).multiplyScalar($),S.copy(d).sub(B),N.copy(d).add(B),U=!0,B.subVectors(H,J),p.dot(B)<0&&(U=!1),u===1&&(i=U),B.subVectors(H,d),B.normalize();const n=Math.abs(p.dot(B));if(n!==0){const e=$/n;B.multiplyScalar(-e),v.subVectors(d,J),tt.copy(v).setLength(e).add(B),I.copy(tt).negate();const x=tt.length(),L=v.length();v.divideScalar(L),R.subVectors(H,d);const X=R.length();switch(R.divideScalar(X),v.dot(I)<L&&R.dot(I)<X&&(Q=!0),G.copy(tt).add(d),I.add(d),ot=!1,Q?U?(N.copy(I),g.copy(I)):(S.copy(I),h.copy(I)):P(),q.strokeLineJoin){case"bevel":b(U,Q,l);break;case"round":T(U,Q),U?a(d,h,S,l,0):a(d,N,g,l,1);break;case"miter":case"miter-clip":default:const et=$*q.strokeMiterLimit/x;if(et<1)if(q.strokeLineJoin!=="miter-clip"){b(U,Q,l);break}else T(U,Q),U?(R.subVectors(G,h).multiplyScalar(et).add(h),D.subVectors(G,S).multiplyScalar(et).add(S),s(h,l,0),s(R,l,0),s(d,l,.5),s(d,l,.5),s(R,l,0),s(D,l,0),s(d,l,.5),s(D,l,0),s(S,l,0)):(R.subVectors(G,g).multiplyScalar(et).add(g),D.subVectors(G,N).multiplyScalar(et).add(N),s(g,l,1),s(R,l,1),s(d,l,.5),s(d,l,.5),s(R,l,1),s(D,l,1),s(d,l,.5),s(D,l,1),s(N,l,1));else Q?(U?(s(k,A,1),s(f,A,0),s(G,l,0),s(k,A,1),s(G,l,0),s(I,l,1)):(s(k,A,1),s(f,A,0),s(G,l,1),s(f,A,0),s(I,l,0),s(G,l,1)),U?S.copy(G):N.copy(G)):U?(s(h,l,0),s(G,l,0),s(d,l,.5),s(d,l,.5),s(G,l,0),s(S,l,0)):(s(g,l,1),s(G,l,1),s(d,l,.5),s(d,l,.5),s(G,l,1),s(N,l,1)),ot=!0;break}}else P()}else P();!W&&u===z-1&&y(C[0],E,m,U,!0,A),A=l,J=d,f.copy(S),k.copy(N)}if(!W)y(d,h,g,U,!1,l);else if(Q&&w){let u=G,p=I;i!==U&&(u=I,p=G),U?(ot||i)&&(p.toArray(w,0*3),p.toArray(w,3*3),ot&&u.toArray(w,1*3)):(ot||!i)&&(p.toArray(w,1*3),p.toArray(w,3*3),ot&&u.toArray(w,0*3))}return r;function c(u,p,n){return n.subVectors(p,u),n.set(-n.y,n.x).normalize()}function s(u,p,n){w&&(w[t]=u.x,w[t+1]=u.y,w[t+2]=0,F&&(F[t]=0,F[t+1]=0,F[t+2]=1),t+=3,_&&(_[o]=p,_[o+1]=n,o+=2)),r+=3}function a(u,p,n,e,x){Y.copy(p).sub(u).normalize(),K.copy(n).sub(u).normalize();let L=Math.PI;const X=Y.dot(K);Math.abs(X)<1&&(L=Math.abs(Math.acos(X))),L/=j,B.copy(p);for(let et=0,st=j-1;et<st;et++)v.copy(B).rotateAround(u,L),s(B,e,x),s(v,e,x),s(u,e,.5),B.copy(v);s(v,e,x),s(n,e,x),s(u,e,.5)}function P(){s(k,A,1),s(f,A,0),s(h,l,0),s(k,A,1),s(h,l,1),s(g,l,0)}function b(u,p,n){p?u?(s(k,A,1),s(f,A,0),s(h,l,0),s(k,A,1),s(h,l,0),s(I,l,1),s(h,n,0),s(S,n,0),s(I,n,.5)):(s(k,A,1),s(f,A,0),s(g,l,1),s(f,A,0),s(I,l,0),s(g,l,1),s(g,n,1),s(N,n,0),s(I,n,.5)):u?(s(h,n,0),s(S,n,0),s(d,n,.5)):(s(g,n,1),s(N,n,0),s(d,n,.5))}function T(u,p){p&&(u?(s(k,A,1),s(f,A,0),s(h,l,0),s(k,A,1),s(h,l,0),s(I,l,1),s(h,A,0),s(d,l,.5),s(I,l,1),s(d,l,.5),s(S,A,0),s(I,l,1)):(s(k,A,1),s(f,A,0),s(g,l,1),s(f,A,0),s(I,l,0),s(g,l,1),s(g,A,1),s(I,l,0),s(d,l,.5),s(d,l,.5),s(I,l,0),s(N,A,1)))}function y(u,p,n,e,x,L){switch(q.strokeLineCap){case"round":x?a(u,n,p,L,.5):a(u,p,n,L,.5);break;case"square":if(x)Y.subVectors(p,u),K.set(Y.y,-Y.x),B.addVectors(Y,K).add(u),v.subVectors(K,Y).add(u),e?(B.toArray(w,1*3),v.toArray(w,0*3),v.toArray(w,3*3)):(B.toArray(w,1*3),B.toArray(w,3*3),v.toArray(w,0*3));else{Y.subVectors(n,u),K.set(Y.y,-Y.x),B.addVectors(Y,K).add(u),v.subVectors(K,Y).add(u);const X=w.length;e?(B.toArray(w,X-1*3),v.toArray(w,X-2*3),v.toArray(w,X-4*3)):(B.toArray(w,X-2*3),v.toArray(w,X-1*3),v.toArray(w,X-4*3))}break}}function V(u){let p=!1;for(let e=1,x=u.length-1;e<x;e++)if(u[e].distanceTo(u[e+1])<M){p=!0;break}if(!p)return u;const n=[];n.push(u[0]);for(let e=1,x=u.length-1;e<x;e++)u[e].distanceTo(u[e+1])>=M&&n.push(u[e]);return n.push(u[u.length-1]),n}}}const Gt=Et({props:{path:null,material:{default:()=>new dt({color:"black",side:bt})}},setup(ut,{expose:C}){const{scene:q,update:j}=Ct("context");function M(F){const _=`<path d="${F}"></path>`,K=new at().parse(_).paths,B=new gt;for(let v=0;v<K.length;v++){const tt=K[v],R=at.createShapes(tt);for(let D=0;D<R.length;D++){const f=R[D],k=new Tt(f),E=new kt(k,ut.material);B.add(E)}}return B}const w=M(ut.path);return jt(()=>q,()=>{q&&(q.add(w),j())},{immediate:!0}),C({mesh:w,update:j}),(F,_)=>null}});export{Gt as default};
